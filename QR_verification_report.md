# QR Code Verification System Report

## Executive Summary
The current QR code check-in system suffers from critical fragmentation and security flaws. There is no unified standard for QR payload formatting across the application (Email vs. In-App), and the verification logic in the **Organizer App** is completely broken. Most critically, the **Backend** does not prevent ticket reuse, allowing a single valid QR code to be scanned indefinitely.

## 1. System Architecture Analysis

The system consists of three distinct components interacting with the check-in API:

1.  **Email System (`src/utils/email.js`):** Generates QR codes sent to users via email.
2.  **User Web App (`dist/index.html`):** Displays "My Passes" QRs and contains a built-in scanner.
3.  **Organizer App (`dist/organizer.app.js`):** A standalone dashboard for hosts to scan tickets.
4.  **Backend API (`src/event_path.js`):** The `POST /checkin` endpoint.

## 2. Identified Flaws

### Flaw #1: Payload Fragmentation (Critical)
There is a fundamental mismatch in how QR codes are generated in different parts of the system.

*   **Email System:** Generates a **JSON String** payload.
    ```json
    {"eventId":"...","ticketId":"...","userId":"..."}
    ```
*   **User Web App ("My Passes"):** Generates a **Hyphenated String** payload.
    ```text
    eventId-ticketId
    ```

**Impact:** A scanner designed for one format will fail to parse the other.

### Flaw #2: Organizer App Logic Failure (Critical)
The Organizer Console (`organizer.app.js`) is hardcoded to parse the hyphenated string format (`eid-uid`) but erroneously treats the second part as a `userId`.

*   **Parsing:** `const [eid, uid] = decodedText.split('-');`
*   **API Call:** Sends `{ eventId: eid, userId: uid }`.
*   **Backend Expectation:** Expects `{ eventId, ticketId }`.

**Impact:**
*   **Email QRs:** Fail immediately (cannot split JSON by hyphen).
*   **User App QRs:** Fail at Backend. The app sends the `ticketId` value in a field named `userId`. The backend ignores `userId` and sees `ticketId` as `undefined`.

### Flaw #3: Backend Replay Attack Vulnerability (Severe)
The backend `POST /checkin` endpoint does not verify if a ticket has already been used.

**Current Logic:**
```javascript
// src/event_path.js
const result = await eventsCollection.updateOne(
    { _id: new ObjectId(eventId), "attendees.ticketId": ticketId },
    { $set: { "attendees.$.status": "checked-in" } }
);

if (result.matchedCount === 0) return Error; // Ticket doesn't exist
return Success; // Ticket exists
```

**Defect:** `updateOne` finds the ticket and sets status to 'checked-in'. If the status is *already* 'checked-in', it simply overwrites it (or does nothing) and reports success.
**Impact:** A user can screenshot their QR code and pass it to unlimited friends. The scanner will show "Verified" for every scan.

## 3. Immediate Invalidation Status
**Does the system promise invalidation immediately upon scan?**
**No.** While the database state is technically updated to "checked-in", the verification logic does not check this state before approving the request. Therefore, the "invalidation" has no practical effect on preventing reuse.

## 4. Recommendations

1.  **Unify QR Format:** Standardize all QR codes (Email and App) to the simple hyphenated string format: `${eventId}-${ticketId}`.
2.  **Fix Organizer Scanner:**
    *   Update parsing logic to handle the standard format.
    *   Ensure the API payload uses the key `ticketId`, not `userId`.
3.  **Secure Backend:**
    *   Modify the database query to only match tickets that are **NOT** checked in.
    *   `{ ..., "attendees.ticketId": ticketId, "attendees.status": { $ne: "checked-in" } }`
    *   If `matchedCount === 0`, check if the ticket exists to differentiate between "Invalid Ticket" and "Already Used".

---
*Report generated by Gemini CLI*
